# Redux - это библиотека для управления состоянием в JavaScript-приложениях. 
  Она основана на КОНЦЕПЦИИ ОДНОНАПРАВЛЕННОГО ПОТОКА ДАННЫХ и является популярным инструментом в разработке веб-приложений.

# Основная идея: 
вся информация о состоянии приложения хранится в единственном объекте - store. 
Состояние приложения в Redux является неизменяемым - его нельзя изменить напрямую и любые изменения состояния осуществляются путем создания и отправки "действий" (actions) в редьюсеры (reducers).
# Действия 
- простые объекты; описывают, что произошло в приложении. 
# Редьюсеры 
- это чистые функции; 
принимают текущее состояние и действие;
возвращают новое состояние. 
Каждый редьюсер отвечает за обновление определенной части состояния.
# Селекторы 
-позволяют извлекать определенные данные из состояния. 
Селекторы необходимы для получения нужной информации из сложной структуры состояния,
избегая необходимости напрямую обращаться к нему.
Для связи Redux со своим приложением используются "привязки" (bindings). 
Обычно это делается с помощью библиотеки react-redux, которая предоставляет инструменты для интеграции Redux с React-приложениями.
Redux позволяет эффективно управлять состоянием приложения, облегчает отслеживание изменений и упрощает тестирование. Она широко используется в разработке веб-приложений на JavaScript и является одной из основных составляющих архитектуры Flux.

# Redux Toolkit 
- это пакет, облегчающий работу с Redux. Он был разработан для решения ТРЕХ главных проблем:
# 1.Слишком сложная настройка хранилища (store) 
Для того, чтобы заставить Redux делать что-то полезное, приходится использовать дополнительные пакеты
# 2. Слишком много шаблонного кода (boilerplate) 
Redux Toolkit предоставляет инструменты для настройки хранилища и выполнения наиболее распространенных операций, а также содержит полезные утилиты, позволяющие упростить код.
# 3. ?????

Redux Toolkit включает в себя следующие API:
# configureStore(): 
обертка для createStore(), упрощающая настройку хранилища с настройками по умолчанию. Позволяет автоматически комбинировать отдельные частичные редукторы (slice reducers), добавлять промежуточные слои или посредников (middlewares), по умолчанию включает redux-thunk (преобразователя), позволяет использовать расширение Redux DevTools (инструменты разработчика Redux)
# createReducer(): 
позволяет использовать таблицу поиска (lookup table) операций для редукторов случая (case reducers) вместо инструкций switch. В данном API используется библиотека immer, позволяющая напрямую изменять иммутабельный код, например, так: 
state.todos[3].completed = true
# createAction(): 
генерирует создателя операции (action creator) для переданного типа операции. Функция имеет переопределенный метод toString(), что позволяет использовать ее вместо константы типа
# createSlice(): 
принимает объект, содержащий редуктор, название части состояния (state slice), начальное значение состояния, и автоматически генерирует частичный редуктор с соответствующими создателями и типами операции
# createAsyncThunk(): 
принимает тип операции и функцию, возвращающую промис, и генерирует thunk, отправляющий типы операции pending/fulfilled/rejected на основе промиса
# createEntityAdapter(): 
генерирует набор переиспользуемых редукторов и селекторов для управления нормализованными данными в хранилище
# createSelector() 
 утилита из библиотеки Reselect

# Как писать фичу
 папка -> types -> типы для одной сущности и для централизрованного состояния
 -> пишем api 
 -> создаем файл slice 
 -> initital state 
 -> async thunk 
 -> сам slice 
 -> добавляем в store

# У промиса есть состояния:
  - fulfilled - удовлетворен - то есть ответ со значением
  - rejected - отвергнут - с ошибкой
  - pending - ожидание результа
